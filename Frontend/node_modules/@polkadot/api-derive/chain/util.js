import { combineLatest, map, of } from 'rxjs';
import { memo, unwrapBlockNumber } from '../util/index.js';
export function createBlockNumberDerive(fn) {
    return (instanceId, api) => memo(instanceId, () => fn(api).pipe(map(unwrapBlockNumber)));
}
export function getAuthorDetails(header, queryAt) {
    const validators = queryAt.session
        ? queryAt.session.validators()
        : of(null);
    // nimbus consensus stores the session key of the block author in header logs
    const { logs: [log] } = header.digest;
    const loggedAuthor = (log && ((log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1]) ||
        (log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1])));
    if (loggedAuthor) {
        // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key
        if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {
            return combineLatest([
                of(header),
                validators,
                queryAt.authorMapping.mappingWithDeposit(loggedAuthor)
                    .pipe(map((opt) => opt.unwrapOr({ account: null }).account))
            ]);
        }
        // fall back to session pallet, if available (ie: manta, calamari), to map session (nimbus) key to author (collator/validator) key
        if (queryAt.session && queryAt.session.queuedKeys) {
            return combineLatest([
                of(header),
                validators,
                queryAt.session.queuedKeys().pipe(map((queuedKeys) => queuedKeys.find((sessionKey) => sessionKey[1].nimbus.toHex() === loggedAuthor.toHex())), map((sessionKey) => (sessionKey) ? sessionKey[0] : null))
            ]);
        }
    }
    // normal operation, non-mapping
    return combineLatest([
        of(header),
        validators,
        of(null)
    ]);
}
