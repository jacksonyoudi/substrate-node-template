"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuthorDetails = exports.createBlockNumberDerive = void 0;
const rxjs_1 = require("rxjs");
const index_js_1 = require("../util/index.js");
function createBlockNumberDerive(fn) {
    return (instanceId, api) => (0, index_js_1.memo)(instanceId, () => fn(api).pipe((0, rxjs_1.map)(index_js_1.unwrapBlockNumber)));
}
exports.createBlockNumberDerive = createBlockNumberDerive;
function getAuthorDetails(header, queryAt) {
    const validators = queryAt.session
        ? queryAt.session.validators()
        : (0, rxjs_1.of)(null);
    // nimbus consensus stores the session key of the block author in header logs
    const { logs: [log] } = header.digest;
    const loggedAuthor = (log && ((log.isConsensus && log.asConsensus[0].isNimbus && log.asConsensus[1]) ||
        (log.isPreRuntime && log.asPreRuntime[0].isNimbus && log.asPreRuntime[1])));
    if (loggedAuthor) {
        // use the author mapping pallet, if available (ie: moonbeam, moonriver), to map session (nimbus) key to author (collator/validator) key
        if (queryAt.authorMapping && queryAt.authorMapping.mappingWithDeposit) {
            return (0, rxjs_1.combineLatest)([
                (0, rxjs_1.of)(header),
                validators,
                queryAt.authorMapping.mappingWithDeposit(loggedAuthor)
                    .pipe((0, rxjs_1.map)((opt) => opt.unwrapOr({ account: null }).account))
            ]);
        }
        // fall back to session pallet, if available (ie: manta, calamari), to map session (nimbus) key to author (collator/validator) key
        if (queryAt.session && queryAt.session.queuedKeys) {
            return (0, rxjs_1.combineLatest)([
                (0, rxjs_1.of)(header),
                validators,
                queryAt.session.queuedKeys().pipe((0, rxjs_1.map)((queuedKeys) => queuedKeys.find((sessionKey) => sessionKey[1].nimbus.toHex() === loggedAuthor.toHex())), (0, rxjs_1.map)((sessionKey) => (sessionKey) ? sessionKey[0] : null))
            ]);
        }
    }
    // normal operation, non-mapping
    return (0, rxjs_1.combineLatest)([
        (0, rxjs_1.of)(header),
        validators,
        (0, rxjs_1.of)(null)
    ]);
}
exports.getAuthorDetails = getAuthorDetails;
